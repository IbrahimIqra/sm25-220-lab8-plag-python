<html>
<head>
<title>A8_Sec07_23301360_Arafa-Alam.txt</title>
</head>
<body bgcolor="white">
<hr/>
A8_Sec07_23301360_Arafa-Alam.txt<p></p><pre>
                                                  Lab-8


# ========================================================Task 1


class minHeap:
    def __init__(self, max_size):
        self.max_size= max_size
        self.data= [None] * (max_size + 1)
        self.length= 0

<a name="0"></a><font color="#FF0000"><a href="match38-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_10.gif"/></a>

    def insert(self, item):
        if self.length&gt;= self.max_size:
            print("heap full")
            return
        self.length+= 1
        self.data[self.length]= item
        self.swim(self.length)

    def swim(self,pos):
        while pos&gt; 1 and self.data[pos]&lt; self.data[po // 2]:
            self.data[pos],self.data[pos// 2]= self.data[pos// 2], self.data[pos]
</font>            pos= pos // 2

    def sink(self,pos):
<a name="2"></a><font color="#0000FF"><a href="match38-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_9.gif"/></a>

        while 2* pos&lt;= self.length:
            child= 2*pos
            if child&lt;self.length and self.data[child] &gt; self.data[child + 1]:
                child+= 1
            if self.data[pos]&lt;= self.data[child]:
                break
            self.data[pos],self.data[child] = self.data[child], self.data[pos]
            pos= child

    def extract_min(self):
</font><a name="4"></a><font color="#FF00FF"><a href="match38-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

        if self.length== 0:
            print("nothing to extract")
            return None
        result = self.data[1]
        self.data[1] = self.data[self.length]
</font>        self.data[self.length] = None
        self.length-= 1
        self.sink(1)
        return result

    def sort(self):
        output= [None] * self.length
        index= 0
        count= self.length
        i= 0
        while i&lt; count:
            output[index]= self.extract_min()
            index+= 1
            i+= 1
        print(output)


# ========================================================Task 2


class maxHeap:
    def __init__(self, max_size):
        self.max_size= max_size
        self.data= [None]*(max_size + 1)
        self.length= 0

<a name="1"></a><font color="#00FF00"><a href="match38-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_10.gif"/></a>

    def insert(self, item):
        if self.length&gt;= self.max_size:
            print("Heap full")
            return
        self.length+= 1
        self.data[self.length]= item
        self.swim(self.length)

    def swim(self, pos):
        while pos &gt; 1 and self.data[pos] &gt; self.data[pos // 2]:
            self.data[pos], self.data[pos // 2] = self.data[pos // 2], self.data[pos]
</font>            pos = pos // 2

    def sink(self, pos):
        while 2 * pos &lt;= self.length:
            child= 2 * pos
<a name="3"></a><font color="#00FFFF"><a href="match38-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

            if child&lt; self.length and self.data[child]&lt; self.data[child+ 1]:
                child+= 1
            if self.data[pos]&gt;= self.data[child]:
                break
            self.data[pos],self.data[child]= self.data[child], self.data[pos]
            pos= child

    def extract_max(self):
</font><a name="5"></a><font color="#FF0000"><a href="match38-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

        if self.length== 0:
            print("Nothing to extract")
            return None
        result = self.data[1]
        self.data[1]= self.data[self.length]
</font>        self.data[self.length]= None
        self.length-= 1
        self.sink(1)
        return result

    def sort(self):
        result= [None] * self.length
        i= 0
        whilei &lt; len(result):
            result[i]= self.extract_max()
            i+= 1
        print(result)


# ========================================================Task 3

def task_distribution(tasks, m):
    load_heap= minHeap(m)
    counter= 0
    while counter&lt; m:
        load_heap.insert(0)
        counter+= 1

    idx= 0
    while idx&lt;len(tasks):
        current= load_heap.extract_min()
        current+= tasks[idx]
        load_heap.insert(current)
        idx+= 1

    result= [None]* m
    i= 0
    while i&lt; m:
        result[i]= load_heap.data[i + 1]
        i += 1

    return result
tasks= [2, 4, 7, 1, 6]
m= 4
result= task_distribution(tasks, m)
sortedheap=minHeap(m)
for i in range(m):
    sortedheap.insert(result[i])
sortedheap.sort()

# ========================================================Task 4
def largest_kth_elements(nums, k):
    heap= maxHeap(len(nums))

    for val in nums:
        heap.insert(val)

    result= [None] * k
    i= 0
    while i&lt; k:
        result[i]= heap.extract_max()
        i+= 1

    return result

print(largest_kth_elements([4, 10, 2, 8, 6, 7], 3))</pre>
</body>
</html>
