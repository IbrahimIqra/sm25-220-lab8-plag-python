<html>
<head>
<title>A8_Sec28_22299395_Ibon-Al-Shaikh-Maruf.txt</title>
</head>
<body bgcolor="white">
<hr/>
A8_Sec13_22201322_Ashrofi-zaman-siam---ASHROFI-ZAMAN-SIAM.txt<p></p><pre>
Task 3

class MinHeap:
    def __init__(self, capacity):
        self.__capacity = capacity
        self.__heap = [None] * capacity  
<a name="0"></a><font color="#FF0000"><a href="match19-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_7.gif"/></a>

        self.__size = 0  
    def __parent(self, index):
        return (index - 1) // 2
    def __left(self, index):
        return 2 * index + 1
    def __right(self, index):
        return 2 * index + 2
    def __swap(self, i, j):
        self.__heap[i], self.__heap[j] = self.__heap[j], self.__heap[i]
    def insert(self, value):
        if self.__size == self.__capacity:
            raise Exception("Heap is full!")
        self.__heap[self.__size] = value
</font><a name="6"></a><font color="#00FF00"><a href="match19-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_2.gif"/></a>

        self.__size += 1
        self.__swim(self.__size - 1)

    def __swim(self, index):
        while index &gt; 0 and self.__heap[index] &lt; self.__heap[self.__parent(index)]:
</font>            self.__swap(index, self.__parent(index))
            index = self.__parent(index)

<a name="2"></a><font color="#0000FF"><a href="match19-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

    def extractMin(self):
        if self.__size == 0:
            raise Exception("Heap is empty!")
        root = self.__heap[0]
        self.__heap[0] = self.__heap[self.__size - 1]
        self.__size -= 1
        self.__sink(0)
        return root

    def __sink(self, index):
        while self.__left(index) &lt; self.__size:
</font>            smaller = self.__left(index)
            if self.__right(index) &lt; self.__size and self.__heap[self.__right(index)] &lt; self.__heap[smaller]:
                smaller = self.__right(index)
            if self.__heap[index] &lt;= self.__heap[smaller]:
                break
            self.__swap(index, smaller)
            index = smaller

    def sort(self):
        result = []
        temp_size = self.__size
        for _ in range(temp_size):
            result.append(self.extractMin())
        return result
    def getHeapArray(self):
        return self.__heap[:self.__size]

class MaxHeap:
    def __init__(self, capacity):
        self.__capacity = capacity
        self.__heap = [None] * capacity
        self.__size = 0
    def __parent(self, index):
        return (index - 1) // 2
    def __left(self, index):
        return 2 * index + 1
    def __right(self, index):
        return 2 * index + 2
    def __swap(self, i, j):
        self.__heap[i], self.__heap[j] = self.__heap[j], self.__heap[i]

    def insert(self, value):
        if self.__size == self.__capacity:
            raise Exception("Heap is full!")
        self.__heap[self.__size] = value
<a name="7"></a><font color="#0000FF"><a href="match19-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_2.gif"/></a>

        self.__size += 1
        self.__swim(self.__size - 1)

    def __swim(self, index):
        while index &gt; 0 and self.__heap[index] &gt; self.__heap[self.__parent(index)]:
</font>            self.__swap(index, self.__parent(index))
            index = self.__parent(index)

<a name="3"></a><font color="#00FFFF"><a href="match19-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

    def extractMax(self):
        if self.__size == 0:
            raise Exception("Heap is empty!")
        root = self.__heap[0]
        self.__heap[0] = self.__heap[self.__size - 1]
        self.__size -= 1
        self.__sink(0)
        return root

    def __sink(self, index):
        while self.__left(index) &lt; self.__size:
</font><a name="1"></a><font color="#00FF00"><a href="match19-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_5.gif"/></a>

            larger = self.__left(index)
            if self.__right(index) &lt; self.__size and self.__heap[self.__right(index)] &gt; self.__heap[larger]:
                larger = self.__right(index)
            if self.__heap[index] &gt;= self.__heap[larger]:
                break
            self.__swap(index, larger)
            index = larger

    def sort(self):
</font>        result = []
        temp_size = self.__size
        for _ in range(temp_size):
            result.append(self.extractMax())
        return result
    def getHeapArray(self):
<a name="5"></a><font color="#FF0000"><a href="match19-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

        return self.__heap[:self.__size]
def schedule_tasks(tasks, m):
    heap = MinHeap(m)
    for _ in range(m):
        heap.insert(0)
    for task in tasks:
        min_load = heap.extractMin()
</font>        new_load = min_load + task
        heap.insert(new_load)
    return heap.getHeapArray()
if __name__ == "__main__":
    print("MinHeap Test:")
    min_heap = MinHeap(10)
    for val in [5, 3, 8, 1, 2]:
        min_heap.insert(val)
    print("Heap array:", min_heap.getHeapArray())
    print("Sorted:", min_heap.sort())
    print("\nMaxHeap Test:")
    max_heap = MaxHeap(10)
    for val in [5, 3, 8, 1, 2]:
        max_heap.insert(val)
    print("Heap array:", max_heap.getHeapArray())
    print("Sorted:", max_heap.sort())
    print("\nTask Scheduling Test:")
    tasks = [2, 4, 7, 1, 6]
    m = 4
    print("Final Loads:", schedule_tasks(tasks, m))

Taskm 4
#TASK 02
class MaxHeap:
    def __init__(self, capacity):
        self.__capacity = capacity
        self.__heap = [None] * capacity
        self.__size = 0
    def __parent(self, index):
        return (index - 1) // 2
    def __left(self, index):
        return 2 * index + 1
    def __right(self, index):
        return 2 * index + 2
    def __swap(self, i, j):
        self.__heap[i], self.__heap[j] = self.__heap[j], self.__heap[i]
    def insert(self, value):
        if self.__size == self.__capacity:
            raise Exception("Heap is full!")
        self.__heap[self.__size] = value
        self.__size += 1
        self.__swim(self.__size - 1)

    def __swim(self, index):
        while index &gt; 0 and self.__heap[index] &gt; self.__heap[self.__parent(index)]:
            self.__swap(index, self.__parent(index))
            index = self.__parent(index)

    def extractMax(self):
        if self.__size == 0:
            raise Exception("Heap is empty!")
        root = self.__heap[0]
        self.__heap[0] = self.__heap[self.__size - 1]
        self.__size -= 1
        self.__sink(0)
        return root

    def __sink(self, index):
        while self.__left(index) &lt; self.__size:
            larger = self.__left(index)
            if self.__right(index) &lt; self.__size and self.__heap[self.__right(index)] &gt; self.__heap[larger]:
                larger = self.__right(index)
            if self.__heap[index] &gt;= self.__heap[larger]:
                break
            self.__swap(index, larger)
            index = larger
<a name="4"></a><font color="#FF00FF"><a href="match19-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_3.gif"/></a>

def top_k_largest(nums, k):
    n = len(nums)
    heap = MaxHeap(n)
    for num in nums:
        heap.insert(num)
    result = []
    for _ in range(k):
        result.append(heap.extractMax())
    return result
</font>if __name__ == "__main__":
    nums = [4, 10, 2, 8, 6, 7]
    k = 3
    print("Top", k, "largest:", top_k_largest(nums, k))


</pre>
</body>
</html>
