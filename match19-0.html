<html>
<head>
<title>A8_Sec28_22299395_Ibon-Al-Shaikh-Maruf.txt</title>
</head>
<body bgcolor="white">
<hr/>
A8_Sec28_22299395_Ibon-Al-Shaikh-Maruf.txt<p></p><pre>
ASSIGNMENT TASKS


Task 3:

class MinHeap:
    def __init__(self, capacity):
        self.__heap = [0] * capacity
        self.__size = 0
        self.capacity = capacity
    def insert(self, value):
        if self.__size == self.capacity:
            raise Exception("Heap is full")
        self.__heap[self.__size] = value
<a name="6"></a><font color="#00FF00"><a href="match19-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

        self.__size += 1
        self.__swim(self.__size - 1)
    def __swim(self, index):
        while index &gt; 0 and self.__heap[index] &lt; self.__heap[(index - 1) // 2]:
</font>            self.__heap[index], self.__heap[(index - 1) // 2] = self.__heap[(index - 1) // 2], self.__heap[index]
            index = (index - 1) // 2
<a name="2"></a><font color="#0000FF"><a href="match19-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

    def extract_min(self):
        if self.__size == 0:
            raise Exception("Heap is empty")
        root = self.__heap[0]
        self.__heap[0] = self.__heap[self.__size - 1]
        self.__size -= 1
        self.__sink(0)
        return root
    def __sink(self, index):
        while 2 * index + 1 &lt; self.__size:
</font>            smallest = 2 * index + 1
            if smallest + 1 &lt; self.__size and self.__heap[smallest + 1] &lt; self.__heap[smallest]:
                smallest += 1
            if self.__heap[index] &lt;= self.__heap[smallest]:
                break
            self.__heap[index], self.__heap[smallest] = self.__heap[smallest], self.__heap[index]
            index = smallest
    def get_heap(self):
<a name="5"></a><font color="#FF0000"><a href="match19-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

        return sorted(self.__heap[:self.__size])
def distribute_tasks(tasks, m):
    heap = MinHeap(m)
    for _ in range(m):
        heap.insert(0)
    for task in tasks:
        min_load = heap.extract_min()
</font>        heap.insert(min_load + task)
    return sorted(heap.get_heap())
tasks = [2, 4, 7, 1, 6]
m = 4
result = distribute_tasks(tasks, m)
print(result)




Task 4:

class MaxHeap:
    def __init__(self, capacity):
        self.__heap = [0] * capacity
        self.__capacity = capacity
<a name="0"></a><font color="#FF0000"><a href="match19-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_11.gif"/></a>

        self.__size = 0
    def __parent(self, index):
        return (index - 1) // 2
    def __left_child(self, index):
        return 2 * index + 1
    def __right_child(self, index):
        return 2 * index + 2
    def __swap(self, i, j):
        self.__heap[i], self.__heap[j] = self.__heap[j], self.__heap[i]
    def insert(self, value):
        if self.__size == self.__capacity:
            raise Exception("Heap is full")
        self.__heap[self.__size] = value
</font><a name="7"></a><font color="#0000FF"><a href="match19-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

        self.__size += 1
        self.__swim(self.__size - 1)
    def __swim(self, index):
        while index &gt; 0 and self.__heap[self.__parent(index)] &lt; self.__heap[index]:
</font>            self.__swap(index, self.__parent(index))
            index = self.__parent(index)
<a name="3"></a><font color="#00FFFF"><a href="match19-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_7.gif"/></a>

    def extractMax(self):
        if self.__size == 0:
            raise Exception("Heap is empty")
        max_value = self.__heap[0]
        self.__heap[0] = self.__heap[self.__size - 1]
        self.__size -= 1
        self.__sink(0)
        return max_value
    def __sink(self, index):
        while self.__left_child(index) &lt; self.__size:
</font><a name="1"></a><font color="#00FF00"><a href="match19-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_8.gif"/></a>

            largest = self.__left_child(index)
            if self.__right_child(index) &lt; self.__size and self.__heap[self.__right_child(index)] &gt; self.__heap[largest]:
                largest = self.__right_child(index)
            if self.__heap[index] &gt;= self.__heap[largest]:
                break
            self.__swap(index, largest)
            index = largest
    def sort(self):
</font>        size = self.__size
        for i in range(size - 1, 0, -1):
            self.__swap(0, i)
            self.__size -= 1
            self.__sink(0)
        self.__size = size
        return self.__heap[:size]
<a name="4"></a><font color="#FF00FF"><a href="match19-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

def top_k_largest(nums, k):
    n = len(nums)
    max_heap = MaxHeap(n)
    for num in nums:
        max_heap.insert(num)
    result = []
    for _ in range(k):
        result.append(max_heap.extractMax())
    return result
</font>nums = [4, 10, 2, 8, 6, 7]
k = 3
print(top_k_largest(nums, k))




</pre>
</body>
</html>
