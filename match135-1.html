<html>
<head>
<title>A8_Sec24_23301498_Nusrat-Tabassum-Mim.txt</title>
</head>
<body bgcolor="white">
<hr/>
A8_Sec28_22201924_Genius-Rabbani---GENIUS-RABBANI.txt<p></p><pre>
<a name="3"></a><font color="#00FFFF"><a href="match135-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

ï»¿#task_03


class MinHeap:
    def __init__(self, cap):
        self.__cap= cap
        self.__heap = [None]*(cap+1)  
        self.__size= 0


    def insert(self, val):
        if self.__cap&lt;=self.__size:
</font>            return
        self.__size += 1
        self.__heap[self.__size] = val
        self.__swim(self.__size)


    def __swim(self, ind):
        while ind&gt;1 and self.__heap[ind // 2]&gt;self.__heap[ind]:
            self.__heap[ind//2], self.__heap[ind]=self.__heap[ind], self.__heap[ind//2]
<a name="2"></a><font color="#0000FF"><a href="match135-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

            ind= ind//2


    def extractMin(self):
        if self.__size == 0:
            return None
        minimum = self.__heap[1]
        self.__heap[1] = self.__heap[self.__size]
        self.__size -= 1
        self.__sink(1)
</font>        return minimum


    def __sink(self, ind):
        while 2 * ind &lt;= self.__size:
            p= 2 *ind
            if p&lt; self.__size and self.__heap[p+1] &lt; self.__heap[p]:
                p+= 1
            if self.__heap[p]&gt;= self.__heap[ind]:
                break
            self.__heap[p], self.__heap[ind]=self.__heap[ind], self.__heap[p]
            ind =p


    def getHeap(self):
        return
        [self.__heap[i] for i in range(1, self.__size+1)]


    def sort(self):
        calculate = [0]*self.__size
        new_size = self.__size
        for i in range(new_size):
            calculate[i] = self.extractMin()
        return calculate




def taskDistrbution(tasks, m):
    heap = MinHeap(m)
    for i in range(m):
        heap.insert(0)


    for i in tasks:
        lowest_load = heap.extractMin()
        new_load =lowest_load+i
        heap.insert(new_load)
 
    return heap.sort()


tasks = [2,4,7,1,6]
m=4
print(taskDistrbution(tasks, m))  








#task_04


<a name="4"></a><font color="#FF00FF"><a href="match135-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

class MaxHeap:
    def __init__(self, cap):
        self.__cap = cap
        self.__heap = [None]*(cap+1)  
        self.__size =0


    def insert(self, val):
        if self.__cap&lt;=self.__size:
</font>            return
        self.__size+=1
<a name="0"></a><font color="#FF0000"><a href="match135-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_15.gif"/></a>

        self.__heap[self.__size] =val
        self.__swim(self.__size)


    def __swim(self, ind):
        while ind &gt; 1 and self.__heap[ind] &gt; self.__heap[ind//2]:
            self.__heap[ind], self.__heap[ind//2] = self.__heap[ind//2], self.__heap[ind]
            ind= ind//2


    def extractMax(self):
        if self.__size == 0:
            return None
        maximum = self.__heap[1]
        self.__heap[1] = self.__heap[self.__size]
        self.__size -= 1
        self.__sink(1)
</font>        return maximum


    def __sink(self, ind):
        while 2 *ind&lt;= self.__size:
            p = 2 *ind
            if self.__size&gt;p and self.__heap[p+1] &gt; self.__heap[p]:
                p+= 1
            if self.__heap[p]&lt;= self.__heap[ind]:
                break
            self.__heap[p], self.__heap[ind]=self.__heap[ind], self.__heap[p]
            ind=p




def k_Toplargest(num, k):
    n = len(num)
    heap = MaxHeap(n)


<a name="1"></a><font color="#00FF00"><a href="match135-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

    for num in num:
        heap.insert(num)


    calculate = [0] *k
    for i in range(k):
         calculate [i] = heap.extractMax()
    return  calculate




num = [4, 10, 2, 8, 6, 7]
k=3
print(k_Toplargest(num, k))</font></pre>
</body>
</html>
