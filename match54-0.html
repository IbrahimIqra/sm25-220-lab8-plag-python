<html>
<head>
<title>A8_Sec24_22101341_Suvro-Singha.txt</title>
</head>
<body bgcolor="white">
<hr/>
A8_Sec24_22101341_Suvro-Singha.txt<p></p><pre>

# CSE220 - Lab 8
# Task 3 
class MinHeap:
  def __init__(self,cap):
    self.arr = [0] *cap   # ekhane heap er jonno array
    self.size =0
    self.cap =cap

  def _swim(self,i):
    while i&gt; 0:
      p = (i - 1) // 2
<a name="5"></a><font color="#FF0000"><a href="match54-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

      if self.arr[i] &lt; self.arr[p]:
        self.arr[i], self.arr[p] = self.arr[p], self.arr[i]
</font>        i = p
      else:
        break

  def _sink(self,i):   #sink operation from sheets 
<a name="0"></a><font color="#FF0000"><a href="match54-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_12.gif"/></a>

    while True:
      l =2 * i + 1
      r = 2* i + 2
      smallest =i
      if l &lt; self.size and  self.arr[l]&lt; self.arr[smallest]:
        smallest = l
      if r &lt; self.size and self.arr[r] &lt; self.arr[smallest]:
        smallest = r
      if smallest != i:
        self.arr[i], self.arr[smallest] = self.arr[smallest], self.arr[i]
</font>        i = smallest
      else:
        break

  def insert(self, x):
    if self.size&gt;= self.cap:   # ekhane heap full hole error dibo
      raise IndexError ("Heap full")
    self.arr [self.size] = x
    self._swim (self.size)
    self.size+= 1
  def extractMin (self):
    if self.size == 0:
      raise IndexError ("Heap empty")
<a name="3"></a><font color="#00FFFF"><a href="match54-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

    root = self.arr [0]
    self.arr[0] =self.arr[self.size - 1]  # last element ke root e ana holo
    self.size -= 1
    self._sink(0)
    return root

  def   to_sorted_list(self):  # shob gula element ke min theke ber kore ascending list banabo
</font>    result = []
    while self.size &gt; 0:
      result.append(self.extractMin())
    return result


<a name="6"></a><font color="#00FF00"><a href="match54-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

def assign_tasks(tasks, m):
  heap = MinHeap(m) # shuru te prottek machine er load 0 dhore nilam
  for _ in range(m):
    heap.insert(0)

  for t in tasks:# prottek task ke minimum load machine e assign 
    curr = heap.extractMin()
</font>    updated = curr + t
    heap.insert(updated)
  return heap.to_sorted_list()



# Driver Code
# ==========================
tasks = [2, 4, 7, 1, 6]
m = 4
final_loads = assign_tasks(tasks, m)

print("Final machine loads:", final_loads)





#task 4 
class MaxHeap:
  def __init__(self, cap):
    self.arr = [0]*cap   # heap array, shuru te 0 diye
    self.size = 0       # current number of elements
    self.cap = cap      # max capacity

  def _swim(self, i):# i index er element up kore heap maintain kora
    while i&gt;0:
      p = (i-1)//2     # parent index
<a name="2"></a><font color="#0000FF"><a href="match54-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

      if self.arr[i] &gt; self.arr[p]:  # jodi child boro hoi parent theke
        self.arr[i], self.arr[p] = self.arr[p], self.arr[i]  # swap
</font>        i = p
      else:
        break         # heap thik ache

  def _sink(self, i):# i index er element down kore heap maintain kora
<a name="1"></a><font color="#00FF00"><a href="match54-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_12.gif"/></a>

    while True:
      l =2*i+1      # left child
      r =2*i+2       # right child
      largest= i
      if l&lt;self.size and self.arr[l]&gt; self.arr[largest]:
        largest= l   # left boro
      if r&lt;self.size and self.arr[r] &gt; self.arr[largest]:
        largest =r     # right boro
      if largest !=i:
        self.arr[i],self.arr[largest] =self.arr[largest], self.arr[i]  # swap
</font>        i =largest
      else:
        break       # heap thik ache

  def insert(self, x):
    # new element add kora
    if self.size &gt;= self.cap:
      raise IndexError("Heap full")  # overflow check
    self.arr[self.size] = x
    self._swim(self.size)            # swim up
    self.size += 1

  def extractMax(self):
    # root element return kora (max)
    if self.size == 0:
      raise IndexError("Heap empty") # underflow check
<a name="4"></a><font color="#FF00FF"><a href="match54-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

    root = self.arr[0]             # max element
    self.arr[0] = self.arr[self.size-1]  # last element ke root e
    self.size -= 1
    self._sink(0)               # sink down
    return root


# Task4 function
# ==========================
def top_k_largest(nums, k):
</font>  heap =  MaxHeap(len(nums))       # max heap create
  for x in nums:
    heap.insert(x)                   # sob element insert
  result = [0]*k
  i =0
  while  i&lt;k:
    result[i]= heap.extractMax()    # k bar extract max
    i+= 1
  return result                      # descending order

# Driver Code
# ==========================
nums = [4,10,2,8,6,7]
k = 3
print("Top", k, "largest:", top_k_largest(nums,k))

</pre>
</body>
</html>
