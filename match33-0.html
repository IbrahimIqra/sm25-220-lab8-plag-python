<html>
<head>
<title>A8_Sec10_23101517_Sazzad-Hossain-Bhuiyan---SAZZAD-HOSSAIN-BHUIYAN.txt</title>
</head>
<body bgcolor="white">
<hr/>
A8_Sec10_23101517_Sazzad-Hossain-Bhuiyan---SAZZAD-HOSSAIN-BHUIYAN.txt<p></p><pre>
#Task-01

<a name="5"></a><font color="#FF0000"><a href="match33-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_1.gif"/></a>

class MinHeap:
    def __init__(self, capacity):
        self.__heap = [0] * capacity
        self.__capacity = capacity
        self.__size = 0

    def __parent(self, index):
</font>        return (index - 1) // 2

    def __left_child(self, index):
        return 2 * index + 1

    def __right_child(self, index):
        return 2 * index + 2

    def __swap(self, i, j):
        temp = self.__heap[i]
        self.__heap[i] = self.__heap[j]
        self.__heap[j] = temp

    def __swim(self, index):
        while index &gt; 0 and self.__heap[index] &lt; self.__heap[self.__parent(index)]:
            self.__swap(index, self.__parent(index))
            index = self.__parent(index)

    def __sink(self, index):
        smallest = index
        while True:
            left = self.__left_child(index)
            right = self.__right_child(index)

<a name="1"></a><font color="#00FF00"><a href="match33-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

            if left &lt; self.__size and self.__heap[left] &lt; self.__heap[smallest]:
                smallest = left
            if right &lt; self.__size and self.__heap[right] &lt; self.__heap[smallest]:
                smallest = right
            if smallest != index:
                self.__swap(index, smallest)
</font>                index = smallest
            else:
                break

    def insert(self, value):
        if self.__size &gt;= self.__capacity:
<a name="6"></a><font color="#00FF00"><a href="match33-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_1.gif"/></a>

            return
        self.__heap[self.__size] = value
        self.__swim(self.__size)
        self.__size += 1

    def extract_min(self):
</font><a name="3"></a><font color="#00FFFF"><a href="match33-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_2.gif"/></a>

        if self.__size == 0:
            return None
        min_value = self.__heap[0]
        self.__heap[0] = self.__heap[self.__size - 1]
        self.__size -= 1
        self.__sink(0)
        return min_value

    def sort(self):
</font>        original_size = self.__size
        while self.__size &gt; 1:
            self.__swap(0, self.__size - 1)
<a name="7"></a><font color="#0000FF"><a href="match33-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_1.gif"/></a>

            self.__size -= 1
            self.__sink(0)
        self.__size = original_size

    def get_heap(self):
        return self.__heap[:self.__size]
</font><a name="8"></a><font color="#00FFFF"><a href="match33-1.html#8" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_1.gif"/></a>

heap = MinHeap(10)
heap.insert(5)
heap.insert(3)
heap.insert(8)
heap.insert(1)
print("Heap after insertion:", heap.get_heap())
print("Extracted min element:", heap.extract_min())
</font>print("Heap after extraction:", heap.get_heap())
heap.sort()
print("Heap sort result:", heap.get_heap())


#Task-02

class MaxHeap:
    def __init__(self, capacity):
        self.__capacity = capacity
        self.__heap = [None] * capacity
        self.__size = 0

    def __swap(self, i, j):
        temp = self.__heap[i]
        self.__heap[i] = self.__heap[j]
        self.__heap[j] = temp

    def __swim(self, index):
        while index &gt; 0:
            parent = (index - 1) // 2
            if self.__heap[index] &gt; self.__heap[parent]:
                self.__swap(index, parent)
                index = parent
            else:
                break

    def __sink(self, index):
        while True:
<a name="0"></a><font color="#FF0000"><a href="match33-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

            left = 2 * index + 1
            right = 2 * index + 2
            largest = index


            if left &lt; self.__size and self.__heap[left] &gt; self.__heap[largest]:
                largest = left


            if right &lt; self.__size and self.__heap[right] &gt; self.__heap[largest]:
                largest = right


            if largest != index:
                self.__swap(index, largest)
</font>                index = largest
            else:
                break

    def insert(self, value):
        if self.__size &gt;= self.__capacity:
            print("Heap is full!")
            return False
        self.__heap[self.__size] = value
        self.__swim(self.__size)
        self.__size += 1
        return True

    def extractMax(self):
        if self.__size == 0:
            print("Heap is empty!")
            return None
        max_value = self.__heap[0]
        self.__heap[0] = self.__heap[self.__size - 1]
        self.__size -= 1
        self.__sink(0)
        return max_value

    def sort(self):
        result = [0] * self.__size
        original_size = self.__size
        for i in range(original_size):
            result[i] = self.extractMax()
        self.__size = original_size
        for i in range(original_size):
            self.insert(result[i])
        return result

    def getHeap(self):
        return self.__heap[:self.__size]

max_heap = MaxHeap(10)
max_heap.insert(5)
max_heap.insert(3)
max_heap.insert(8)
max_heap.insert(1)
print("Heap after inserts:", max_heap.getHeap())
print("Extracted max:", max_heap.extractMax())
print("Heap after extraction:", max_heap.getHeap())
sorted_array = max_heap.sort()
print("Sorted array:", sorted_array)

#Task-03

import numpy as np
class CustomHeap:
    def __init__(self, size):
        self.heap = [0] * size
        self.current_size = 0

    def insert(self, value):
        if self.current_size &lt; len(self.heap):
            self.heap[self.current_size] = value
            self._bubble_up(self.current_size)
            self.current_size += 1

<a name="2"></a><font color="#0000FF"><a href="match33-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

    def extract_min(self):
        if self.current_size == 0:
            return None
        min_value = self.heap[0]
        self.current_size -= 1
        self.heap[0] = self.heap[self.current_size]
        self._bubble_down(0)
        return min_value

    def _bubble_up(self, index):
        parent = (index - 1) // 2
</font><a name="4"></a><font color="#FF00FF"><a href="match33-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_2.gif"/></a>

        while index &gt; 0 and self.heap[index] &lt; self.heap[parent]:
            self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]
            index = parent
            parent = (index - 1) // 2
</font>
    def _bubble_down(self, index):
        smallest = index
        left = 2 * index + 1
        right = 2 * index + 2

        if left &lt; self.current_size and self.heap[left] &lt; self.heap[smallest]:
            smallest = left
        if right &lt; self.current_size and self.heap[right] &lt; self.heap[smallest]:
            smallest = right

        if smallest != index:
            self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]
            self._bubble_down(smallest)


def distribute_tasks(tasks, m):
    if m == 0:
        return []

    task_heap = CustomHeap(m)

    for i in range(m):
        task_heap.insert(0)

    for task in tasks:
        current_min = task_heap.extract_min()
        task_heap.insert(current_min + task)

    result = []
    while task_heap.current_size &gt; 0:
        result.append(task_heap.extract_min())

    return result

tasks = np.array([2, 4, 7, 1, 6], dtype=int)
m = 4
result = distribute_tasks(tasks, m)
print(result)



# TASK_04
class MaxHeap:
    def __init__(self, capacity):
        self.heap = [0] * capacity
        self.size = 0

    def insert(self, value):
        if self.size &gt;= len(self.heap):
            return
        self.heap[self.size] = value
        self.size += 1
        self._sift_up(self.size - 1)

    def _sift_up(self, index):
        parent = (index - 1) // 2
        while index &gt; 0 and self.heap[index] &gt; self.heap[parent]:
            self._swap(index, parent)
            index = parent
            parent = (index - 1) // 2

    def _sift_down(self, index):
        largest = index
        left = 2 * index + 1
        right = 2 * index + 2

        if left &lt; self.size and self.heap[left] &gt; self.heap[largest]:
            largest = left
        if right &lt; self.size and self.heap[right] &gt; self.heap[largest]:
            largest = right
        if largest != index:
            self._swap(index, largest)
            self._sift_down(largest)

    def _swap(self, i, j):
<a name="9"></a><font color="#FF00FF"><a href="match33-1.html#9" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_1.gif"/></a>

        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]

    def extract_max(self):
        if self.size == 0:
</font>            return None
        max_val = self.heap[0]
        self.heap[0] = self.heap[self.size - 1]
        self.size -= 1
        self._sift_down(0)
        return max_val


def find_top_k_largest(nums, k):
    max_heap = MaxHeap(len(nums))
    for num in nums:
        max_heap.insert(num)

    result = []
    for i in range(k):
        max_val = max_heap.extract_max()
        if max_val is not None:
            result.append(max_val)

    return result
nums = np.array([4, 10, 2, 8, 6, 7])
k = 3
result = find_top_k_largest(nums, k)
print(result)</pre>
</body>
</html>
