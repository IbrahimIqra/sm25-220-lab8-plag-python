<html>
<head>
<title>A8_sec28_23241058_Fariha-Afreen-Preety---FARIHA-AFREEN-PREETY.txt</title>
</head>
<body bgcolor="white">
<hr/>
A8_Sec08_23101380_MD.-Zilkaful-Rauf-Khan-Mridul.txt<p></p><pre>
# Lab 8

<a name="7"></a><font color="#0000FF"><a href="match10-0.html#7" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

class MinHeap:
    def __init__(self, capacity):
        self._heap = [0] * capacity
        self._size = 0

    def insert(self, value):
        if self._size == len(self._heap):
</font>            return
        self._heap[self._size] = value
        self._swim(self._size)
        self._size += 1

    def _swim(self, index):
        parent = (index - 1) // 2
<a name="3"></a><font color="#00FFFF"><a href="match10-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_6.gif"/></a>

        while index &gt; 0 and self._heap[index] &lt; self._heap[parent]:
            self._heap[index], self._heap[parent] = self._heap[parent], self._heap[index]
            index = parent
            parent = (index - 1) // 2
</font>
    def extractMin(self):
        if self._size == 0:
<a name="5"></a><font color="#FF0000"><a href="match10-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

            return None
        min_val = self._heap[0]
        self._heap[0] = self._heap[self._size - 1]
        self._size -= 1
</font>        self._sink(0)
        return min_val

    def _sink(self, index):
        left = 2 * index + 1
        right = 2 * index + 2
        smallest = index
<a name="1"></a><font color="#00FF00"><a href="match10-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_11.gif"/></a>

        if left &lt; self._size and self._heap[left] &lt; self._heap[smallest]:
            smallest = left
        if right &lt; self._size and self._heap[right] &lt; self._heap[smallest]:
            smallest = right
        if smallest != index:
            self._heap[index], self._heap[smallest] = self._heap[smallest], self._heap[index]
            self._sink(smallest)
</font>
    def sort(self):
        sorted_arr = []
        original_size = self._size
        for _ in range(original_size):
            sorted_arr.append(self.extractMin())
        return sorted_arr

<a name="9"></a><font color="#FF00FF"><a href="match10-0.html#9" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

class MaxHeap:
    def __init__(self, capacity):
        self._heap = [0] * capacity
        self._size = 0

    def insert(self, value):
        if self._size == len(self._heap):
</font>            return
        self._heap[self._size] = value
        self._swim(self._size)
        self._size += 1

    def _swim(self, index):
        parent = (index - 1) // 2
<a name="2"></a><font color="#0000FF"><a href="match10-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

        while index &gt; 0 and self._heap[index] &gt; self._heap[parent]:
            self._heap[index], self._heap[parent] = self._heap[parent], self._heap[index]
            index = parent
            parent = (index - 1) // 2
</font>
    def extractMax(self):
        if self._size == 0:
<a name="6"></a><font color="#00FF00"><a href="match10-0.html#6" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_4.gif"/></a>

            return None
        max_val = self._heap[0]
        self._heap[0] = self._heap[self._size - 1]
        self._size -= 1
</font>        self._sink(0)
        return max_val

    def _sink(self, index):
        left = 2 * index + 1
        right = 2 * index + 2
        largest = index
<a name="0"></a><font color="#FF0000"><a href="match10-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_11.gif"/></a>

        if left &lt; self._size and self._heap[left] &gt; self._heap[largest]:
            largest = left
        if right &lt; self._size and self._heap[right] &gt; self._heap[largest]:
            largest = right
        if largest != index:
            self._heap[index], self._heap[largest] = self._heap[largest], self._heap[index]
            self._sink(largest)
</font>
# Task 3 - Distribute Tasks
<a name="8"></a><font color="#00FFFF"><a href="match10-0.html#8" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

def distribute_tasks(tasks, m):
    heap = MinHeap(m)
    for _ in range(m):
        heap.insert(0)
    for task in tasks:
        min_load = heap.extractMin()
</font>        heap.insert(min_load + task)
    result = []
    for _ in range(m):
        result.append(heap.extractMin())
    return result

# Task 4 - Top K Largest
<a name="4"></a><font color="#FF00FF"><a href="match10-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

def top_k_largest(nums, k):
    heap = MaxHeap(len(nums))
    for num in nums:
        heap.insert(num)
    result = []
    for _ in range(k):
        result.append(heap.extractMax())
    return result</font></pre>
</body>
</html>
