<html>
<head>
<title>A8_Sec07_23301360_Arafa-Alam.txt</title>
</head>
<body bgcolor="white">
<hr/>
A8_Sec12_22299403_Jubair-Ahmed.txt<p></p><pre>
ï»¿Task 1
class MinHeap:
    def __init__(self, capacity):
        self.__capacity = capacity
        self.__size = 0
        self.__heap = [0] * (capacity + 1)  # 1-based index


<a name="0"></a><font color="#FF0000"><a href="match38-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_12.gif"/></a>

    def insert(self, value):
        if self.__size &gt;= self.__capacity:
            print("Heap is full!")
            return
        self.__size += 1
        self.__heap[self.__size] = value
        self.__swim(self.__size)


    def __swim(self, k):
        while k &gt; 1 and self.__heap[k] &lt; self.__heap[k // 2]:
            self.__heap[k], self.__heap[k // 2] = self.__heap[k // 2], self.__heap[k]
</font>            k //= 2


<a name="4"></a><font color="#FF00FF"><a href="match38-0.html#4" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

    def extractMin(self):
        if self.__size == 0:
            print("Heap is empty!")
            return None
        min_val = self.__heap[1]
        self.__heap[1] = self.__heap[self.__size]
</font>        self.__size -= 1
        self.__sink(1)
        return min_val


    def __sink(self, k):
<a name="2"></a><font color="#0000FF"><a href="match38-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_11.gif"/></a>

        while 2 * k &lt;= self.__size:
            j = 2 * k
            if j &lt; self.__size and self.__heap[j] &gt; self.__heap[j + 1]:
                j += 1
            if self.__heap[k] &lt;= self.__heap[j]:
                break
            self.__heap[k], self.__heap[j] = self.__heap[j], self.__heap[k]
            k = j


    def sort(self):
</font>        result = []
        while self.__size &gt; 0:
            result.append(self.extractMin())
        return result


Task 2
class MaxHeap:
    def __init__(self, capacity):
        self.__capacity = capacity
        self.__size = 0
        self.__heap = [0] * (capacity + 1)


<a name="1"></a><font color="#00FF00"><a href="match38-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_12.gif"/></a>

    def insert(self, value):
        if self.__size &gt;= self.__capacity:
            print("Heap is full!")
            return
        self.__size += 1
        self.__heap[self.__size] = value
        self.__swim(self.__size)


    def __swim(self, k):
        while k &gt; 1 and self.__heap[k] &gt; self.__heap[k // 2]:
            self.__heap[k], self.__heap[k // 2] = self.__heap[k // 2], self.__heap[k]
</font>            k //= 2


<a name="5"></a><font color="#FF0000"><a href="match38-0.html#5" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

    def extractMax(self):
        if self.__size == 0:
            print("Heap is empty!")
            return None
        max_val = self.__heap[1]
        self.__heap[1] = self.__heap[self.__size]
</font>        self.__size -= 1
        self.__sink(1)
        return max_val


    def __sink(self, k):
        while 2 * k &lt;= self.__size:
            j = 2 * k
<a name="3"></a><font color="#00FFFF"><a href="match38-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_7.gif"/></a>

            if j &lt; self.__size and self.__heap[j] &lt; self.__heap[j + 1]:
                j += 1
            if self.__heap[k] &gt;= self.__heap[j]:
                break
            self.__heap[k], self.__heap[j] = self.__heap[j], self.__heap[k]
            k = j


    def sort(self):
</font>        result = []
        while self.__size &gt; 0:
            result.append(self.extractMax())
        return result


Task 3
def distribute_tasks(tasks, m):


    heap = [(0, i) for i in range(m)]
    heapq.heapify(heap)


    # storing total final load
    res = [0] * m


    for i in tasks:
        a, b = heapq.heappop(heap)   #machine e minimum load


        a += i      #current task
        res[b] = a                   #update
        heapq.heappush(heap, (a, b))   #final push


    return res
Task 4
def top_k_largest(nums, k):


    heap = MaxHeap(len(nums))
    for i in nums:
        heap.insert(i)




    listt = []
    for _ in range(k):
        listt.append(heap.extractMax())




    return listt</pre>
</body>
</html>
