<html>
<head>
<title>A8_Sec12_22201990_Shakil-Fahim.txt</title>
</head>
<body bgcolor="white">
<hr/>
A8_Sec12_22201990_Shakil-Fahim.txt<p></p><pre>
class MaxHeap:
    def __init__(self, capacity):
        self.__array=[0]*capacity 
        self.__size=0 
    
<a name="3"></a><font color="#00FFFF"><a href="match94-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_4.gif"/></a>

    def __parent(self, i):
        return (i-1)//2
    
    def __left_child(self, i):
        return 2*i+1
    
    def __right_child(self, i):
        return 2*i+2
    
    def swim(self, i):
</font>        while i &gt; 0 and self.__array[self.__parent(i)]&lt;self.__array[i]:
            self.__array[i],self.__array[self.__parent(i)]=self.__array[self.__parent(i)],self.__array[i]
            i=self.__parent(i)
    
    def insert(self, value):
<a name="5"></a><font color="#FF0000"><a href="match94-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_3.gif"/></a>

        if self.__size&gt;=len(self.__array):
            raise Exception("Heap is full")
        self.__array[self.__size]=value
        self.__size +=1
        self.swim(self.__size-1)
    
    def sink(self, i):
</font>        while self.__left_child(i)&lt;self.__size:
            largest = self.__left_child(i)
            if self.__right_child(i)&lt;self.__size and self.__array[self.__right_child(i)]&gt;self.__array[largest]:
                largest = self.__right_child(i)
            if self.__array[i]&lt;self.__array[largest]:
                self.__array[i],self.__array[largest]=self.__array[largest],self.__array[i]
                i=largest
            else:
                break
    
<a name="0"></a><font color="#FF0000"><a href="match94-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

    def extractMax(self):
        if self.__size==0:
            raise Exception("Heap is empty")
        max_val=self.__array[0]
        self.__array[0]=self.__array[self.__size-1]
        self.__size-=1
        self.sink(0)
        return max_val
    
    def sort(self):
        original_size=self.__size
</font>        sorted_array=[0] * original_size
        for i in range(original_size):
            sorted_array[i]=self.extractMax()
        self.__size=original_size
        return sorted_array
    
    def get_heap(self):
        return self.__array[:self.__size]

class MinHeap:
    def __init__(self, capacity):
        self.__array=[0]*capacity 
        self.__size=0 
    
<a name="4"></a><font color="#FF00FF"><a href="match94-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

    def __parent(self, i):
        return (i-1)//2
    
    def __left_child(self, i):
        return 2*i+1
    
    def __right_child(self, i):
        return 2*i+2
    
    def swim(self, i):
</font>        while i&gt;0 and self.__array[self.__parent(i)]&gt;self.__array[i]:
            self.__array[i], self.__array[self.__parent(i)]=self.__array[self.__parent(i)], self.__array[i]
            i = self.__parent(i)
    
    def insert(self, value):
<a name="6"></a><font color="#00FF00"><a href="match94-1.html#6" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_3.gif"/></a>

        if self.__size&gt;=len(self.__array):
            raise Exception("Heap is full")
        self.__array[self.__size] = value
        self.__size+=1
        self.swim(self.__size-1)
    
    def sink(self, i):
</font>        while self.__left_child(i)&lt;self.__size:
            smallest=self.__left_child(i)
            if self.__right_child(i)&lt;self.__size and self.__array[self.__right_child(i)]&lt;self.__array[smallest]:
                smallest=self.__right_child(i)
            if self.__array[i] &gt; self.__array[smallest]:
                self.__array[i], self.__array[smallest]=self.__array[smallest], self.__array[i]
                i=smallest
            else:
                break
    
<a name="1"></a><font color="#00FF00"><a href="match94-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

    def extractMin(self):
        if self.__size==0:
            raise Exception("Heap is empty")
        min_val=self.__array[0]
        self.__array[0]=self.__array[self.__size - 1]
        self.__size-=1
        self.sink(0)
        return min_val
    
    def get_heap(self):
</font>        return self.__array[:self.__size]
#task3
<a name="7"></a><font color="#0000FF"><a href="match94-1.html#7" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_3.gif"/></a>

def distribute_tasks(tasks, m):
    heap=MinHeap(m)
    for _ in range(m):
        heap.insert(0)
    
    for task in tasks:
        smallest_load=heap.extractMin()
</font>        updated_load=smallest_load+task
        heap.insert(updated_load)
    
    return heap.get_heap()
#task4
<a name="2"></a><font color="#0000FF"><a href="match94-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_4.gif"/></a>

def top_k_largest(nums, k):
    heap=MaxHeap(len(nums))
    for num in nums:
        heap.insert(num)
    result=[0]*k
    for i in range(k):
        result[i]=heap.extractMax()
</font>    return result

tasks=[2, 4, 7, 1, 6]
m=4
result = distribute_tasks(tasks, m)
print(result)

nums=[4, 10, 2, 8, 6, 7]
k=3
result=top_k_largest(nums, k)
print(result)</pre>
</body>
</html>
