<html>
<head>
<title>A8_Sec24_24341062_Madhuri-Mazumder.txt</title>
</head>
<body bgcolor="white">
<hr/>
A8_Sec24_24341062_Madhuri-Mazumder.txt<p></p><pre>
#task-1
class MinHeap:
    def __init__(self,capcity):
        self.arr= [0]*capcity
        self.n=0
        self.cap= capcity

    def insert(self,val):
        if self.n&gt;= self.cap:
            print("heap full!!")
            return
        self.arr[self.n]= val
        self.swimup(self.n)
        self.n +=1

<a name="2"></a><font color="#0000FF"><a href="match25-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_9.gif"/></a>

    def swimup(self,idx):
        while idx&gt;0:
            parent =(idx-1)//2
            if self.arr[idx]&lt;self.arr[parent]:
                tmp = self.arr[idx]
                self.arr[idx]= self.arr[parent]
                self.arr[parent] =tmp
                idx=parent
            else:
                break

    def extractMin(self):
        if self.n== 0:
</font>            return None
<a name="4"></a><font color="#FF00FF"><a href="match25-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

        ans =self.arr[0]
        self.arr[0]= self.arr[self.n-1]
        self.n -=1
        self.sinkdown(0)
        return ans

    def sinkdown(self,i):
</font><a name="0"></a><font color="#FF0000"><a href="match25-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_11.gif"/></a>

        while True:
            l=2*i+1
            r=2*i+2
            sm=i
            if l&lt;self.n and self.arr[l]&lt;self.arr[sm]:
                sm = l
            if r&lt; self.n and self.arr[r]&lt; self.arr[sm]:
                sm= r
            if sm!= i:
                t= self.arr[i]
                self.arr[i]= self.arr[sm]
                self.arr[sm] =t
</font>                i =sm
            else:
                break

    def sort(self):
        a =[]
        while self.n&gt; 0:
            a.append(self.extractMin())
        return a


#task-2
class MaxHeap:
    def __init__(self,capcity):
        self.data =[0]*capcity
        self.sz=0
        self.cap= capcity

    def insert(self,v):
        if self.sz&gt;= self.cap:
            print("heap full!!")
            return
        self.data[self.sz]= v
        self.swim(self.sz)
        self.sz +=1

<a name="3"></a><font color="#00FFFF"><a href="match25-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_6.gif"/></a>

    def swim(self,i):
        while i&gt;0:
            p=(i-1)//2
            if self.data[i]&gt; self.data[p]:
                tmp=self.data[i]
                self.data[i]= self.data[p]
                self.data[p]= tmp
</font>                i=p
            else:
                break

    def extractMax(self):
        if self.sz==0:
            return None
<a name="5"></a><font color="#FF0000"><a href="match25-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

        ans=self.data[0]
        self.data[0]= self.data[self.sz-1]
        self.sz -=1
        self.sink(0)
        return ans

    def sink(self,i):
</font><a name="1"></a><font color="#00FF00"><a href="match25-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_11.gif"/></a>

        while True:
            l=2*i+1
            r=2*i+2
            big=i
            if l&lt; self.sz and self.data[l]&gt; self.data[big]:
                big=l
            if r&lt; self.sz and self.data[r]&gt; self.data[big]:
                big=r
            if big!= i:
                t=self.data[i]
                self.data[i]= self.data[big]
                self.data[big]=t
</font>                i=big
            else:
                break

    def sort(self):
        out=[]
        while self.sz&gt;0:
            out.append(self.extractMax())
        return out


#task-3
def distribute_tasks(tasks,m):
    heap= MinHeap(m)
    for i in range(m):
        heap.insert(0)
    for t in tasks:
        x= heap.extractMin()
        newv=x+t
        heap.insert(newv)
    res=[]
    for j in range(heap.n):
        res.append(heap.arr[j])
    return res


#task-4
def find_top_k_largest(nums,k):
    heap= MaxHeap(len(nums))
    for num in nums:
        heap.insert(num)
    ans=[]
    for i in range(k):
        ans.append(heap.extractMax())
    return ans


if __name__=="__main__":
    # task-1 driver code
    print("MinHeap test")
    h= MinHeap(10)
    h.insert(5)
    h.insert(3)
    h.insert(8)
    h.insert(1)
    print("extract:",h.extractMin())
    print("extract:",h.extractMin())
    # task-2 driver code
    print("\nMaxHeap test")
    mh= MaxHeap(10)
    mh.insert(4)
    mh.insert(9)
    mh.insert(2)
    print("extract:",mh.extractMax())
    print("extract:",mh.extractMax())
    # task-3 driver code
    print("\nDistribute")
    tasks=[2,4,7,1,6]
    print(distribute_tasks(tasks,3))
    # task-4 driver code
    print("\nTop k largest")
    arr=[4,10,2,8,6,7]
    print(find_top_k_largest(arr,3))
</pre>
</body>
</html>
