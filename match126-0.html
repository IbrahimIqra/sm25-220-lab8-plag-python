<html>
<head>
<title>A8_Sec26_22301089_Safin-Ahmed-Tonmoy.txt</title>
</head>
<body bgcolor="white">
<hr/>
A8_Sec26_22301089_Safin-Ahmed-Tonmoy.txt<p></p><pre>
#Task-1
class MinHeap:
    def __init__(self):
        self.heap = []
        self.size = 0

    def insert(self, value):
        self.heap.append(value)
        self.size += 1
        self.swim(self.size - 1)

<a name="0"></a><font color="#FF0000"><a href="match126-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_6.gif"/></a>

    def swim(self, index):
        parent = (index - 1) // 2
        while index &gt; 0 and self.heap[index] &lt; self.heap[parent]:
            self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]
            index = parent
            parent = (index - 1) // 2

    def extractMin(self):
        if self.size == 0:
</font>            raise IndexError("Heap is empty")
        min_value = self.heap[0]
        self.heap[0] = self.heap[self.size - 1]
        self.heap.pop()
        self.size -= 1
        self.sink(0)
        return min_value

    def sink(self, index):
<a name="2"></a><font color="#0000FF"><a href="match126-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

        while True:
            left_child = 2 * index + 1
            right_child = 2 * index + 2
            smallest = index
            if left_child &lt; self.size and self.heap[left_child] &lt; self.heap[smallest]:
                smallest = left_child
            if right_child &lt; self.size and self.heap[right_child] &lt; self.heap[smallest]:
                smallest = right_child
            if smallest == index:
</font>                break
            self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]
            index = smallest

    def sort(self, array):
        self.heap = []
        self.size = 0
        for value in array:
            self.insert(value)

        sorted_array = []
        while self.size &gt; 0:
            sorted_array.append(self.extractMin())
        return sorted_array
if __name__ == "__main__":
    heap = MinHeap()
    heap.insert(5)
    heap.insert(3)
    heap.insert(8)
    heap.insert(1)

    print("Extracted Min:", heap.extractMin())

    array_to_sort = [10, 4, 9, 2, 8]
    sorted_array = heap.sort(array_to_sort)
    print("Sorted Array:", sorted_array)


#Task-02

class MaxHeap:
    def __init__(self):
        self.__heap = []
        self.__size = 0

    def insert(self, val):
        self.__heap.append(val)
        self.__size += 1
        self.__swim(self.__size - 1)
<a name="1"></a><font color="#00FF00"><a href="match126-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

    def __swim(self, index):
        parent = (index - 1) // 2
        while index &gt; 0 and self.__heap[index] &gt; self.__heap[parent]:
            self.__heap[index], self.__heap[parent] = self.__heap[parent], self.__heap[index]
            index = parent
            parent = (index - 1) // 2

    def extractMax(self):

        if self.__size == 0:
</font>            raise IndexError("Heap is empty")
        max_value = self.__heap[0]
        self.__heap[0] = self.__heap[self.__size - 1]
        self.__heap.pop()
        self.__size -= 1
        self.__sink(0)
        return max_value

    def __sink(self, index):
<a name="3"></a><font color="#00FFFF"><a href="match126-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_6.gif"/></a>

        while True:
            left_child = 2 * index + 1
            right_child = 2 * index + 2
            largest = index

            if left_child &lt; self.__size and self.__heap[left_child] &gt; self.__heap[largest]:
                largest = left_child

            if right_child &lt; self.__size and self.__heap[right_child] &gt; self.__heap[largest]:
                largest = right_child

            if largest == index:
</font>                break

            self.__heap[index], self.__heap[largest] = self.__heap[largest], self.__heap[index]
            index = largest

    def sort(self, arr):
        self.__heap = []
        self.__size = 0
        for value in arr:
            self.insert(value)

        sorted_array = []
        while self.__size &gt; 0:
            sorted_array.append(self.extractMax())
        return sorted_array
if __name__ == "__main__":
    max_heap = MaxHeap()
    max_heap.insert(5)
    max_heap.insert(3)
    max_heap.insert(8)
    max_heap.insert(1)

    print("Extracted Max:", max_heap.extractMax())
    array_to_sort = [10, 4, 9, 2, 8]
    sorted_array = max_heap.sort(array_to_sort)
    print("Sorted Array:", sorted_array)

#Task-03
import heapq

def distribute_tasks(tasks, m):
    heap = [0] * m
    heapq.heapify(heap)
    for task in tasks:
        smallest_load = heapq.heappop(heap)
        smallest_load += task
        heapq.heappush(heap, smallest_load)
    return list(heap)

tasks = [2, 4, 7, 1, 6]
m = 4
output = distribute_tasks(tasks, m)
print(output)

#task-3(i)
import heapq

heap = [0, 0, 0, 0]
heapq.heapify(heap)

print("Initial Heap:", heap)

smallest_load = heapq.heappop(heap)
print("Extracted Smallest Load:", smallest_load)
print("Heap After Extraction:", heap)

updated_load = smallest_load + 2
print("Updated Load (Smallest Load + Processing Time):", updated_load)

heapq.heappush(heap, updated_load)
print("Heap After Reinserting Updated Load:", heap)


#task-3(ii)
import heapq

heap = [0, 0, 0, 2]
heapq.heapify(heap)

print("Initial Heap:", heap)

smallest_load = heapq.heappop(heap)
print("Extracted Smallest Load:", smallest_load)
print("Heap After Extraction:", heap)

updated_load = smallest_load + 4
print("Updated Load (Smallest Load + Processing Time):", updated_load)

heapq.heappush(heap, updated_load)
print("Heap After Reinserting Updated Load:", heap)


#task-3(iii)
import heapq
heap = [0, 4, 2, 0]
heapq.heapify(heap)
print("Initial Heap:", heap)

smallest_load = heapq.heappop(heap)
print("Extracted Smallest Load:", smallest_load)
print("Heap After Extraction:", heap)

updated_load = smallest_load + 7
print("Updated Load (Smallest Load + Processing Time):", updated_load)

heapq.heappush(heap, updated_load)
print("Heap After Reinserting Updated Load:", heap)


#task-3(iv)
import heapq
heap = [0, 4, 2, 7]
heapq.heapify(heap)

print("Initial Heap:", heap)

smallest_load = heapq.heappop(heap)
print("Extracted Smallest Load:", smallest_load)
print("Heap After Extraction:", heap)

updated_load = smallest_load + 1
print("Updated Load (Smallest Load + Processing Time):", updated_load)

heapq.heappush(heap, updated_load)
print("Heap After Reinserting Updated Load:", heap)



#task-3(v)
import heapq

heap = [1, 2, 7, 4]
heapq.heapify(heap)

print("Initial Heap:", heap)

smallest_load = heapq.heappop(heap)
print("Extracted Smallest Load:", smallest_load)
print("Heap After Extraction:", heap)

updated_load = smallest_load + 6
print("Updated Load (Smallest Load + Processing Time):", updated_load)

heapq.heappush(heap, updated_load)
print("Heap After Reinserting Updated Load:", heap)



#task-4
import heapq
def find_top_k_largest(nums, k):

    max_heap = [-num for num in nums]
    heapq.heapify(max_heap)
    top_k = []
    for _ in range(k):
        top_k.append(-heapq.heappop(max_heap))
    return top_k

nums = [4, 10, 2, 8, 6, 7]
k = 3
result = find_top_k_largest(nums, k)
print("Top k largest elements:", result)




</pre>
</body>
</html>
